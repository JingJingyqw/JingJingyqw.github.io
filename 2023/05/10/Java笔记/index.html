

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="一. 第三方登录   应该在你的登录页面放上一个”码云登录” 的按钮  点击这个按钮应该—&gt;码云登录的页面(按钮的链接就是oauth文档的步骤A) 用户点击授权—&gt;第三方认证服务器(码云,qq)会   请求咱们设置好的回调地址请求参数携带 code  http:&#x2F;&#x2F;127.0.0.1:9001&#x2F;callback?code&#x3D;f9f1da4def040151e8fc09432104d7f1">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2023/05/10/Java%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="一. 第三方登录   应该在你的登录页面放上一个”码云登录” 的按钮  点击这个按钮应该—&gt;码云登录的页面(按钮的链接就是oauth文档的步骤A) 用户点击授权—&gt;第三方认证服务器(码云,qq)会   请求咱们设置好的回调地址请求参数携带 code  http:&#x2F;&#x2F;127.0.0.1:9001&#x2F;callback?code&#x3D;f9f1da4def040151e8fc09432104d7f1">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/gg/Image-168371860712372.png">
<meta property="og:image" content="http://example.com/gg/Image-168371858940268.png">
<meta property="og:image" content="http://example.com/gg/Image-168371858470966.png">
<meta property="og:image" content="http://example.com/gg/Image-168371857395364.png">
<meta property="og:image" content="http://example.com/gg/Image-168371856898462.png">
<meta property="og:image" content="http://example.com/gg/Image-168371855618560.png">
<meta property="og:image" content="http://example.com/gg/Image-168371855153558.png">
<meta property="og:image" content="http://example.com/gg/Image-168371854748556.png">
<meta property="og:image" content="http://example.com/gg/Image-168371854322454.png">
<meta property="og:image" content="en-resource://database/582:0">
<meta property="og:image" content="en-resource://database/584:0">
<meta property="og:image" content="http://example.com/gg/Image-168371851582052.png">
<meta property="og:image" content="http://example.com/gg/Image-168371843142942.png">
<meta property="og:image" content="http://example.com/gg/Image-168371842789540.png">
<meta property="og:image" content="http://example.com/gg/Image-168371850197550.png">
<meta property="og:image" content="http://example.com/gg/Image-168371849503648.png">
<meta property="og:image" content="http://example.com/gg/Image-168371848032546.png">
<meta property="og:image" content="http://example.com/gg/Image-168371844615744.png">
<meta property="og:image" content="http://example.com/gg/Image-168371841326638.png">
<meta property="og:image" content="http://example.com/gg/Image-168371840807636.png">
<meta property="og:image" content="http://example.com/gg/Image-168371840115234.png">
<meta property="og:image" content="http://example.com/gg/Image-168371839762232.png">
<meta property="og:image" content="http://example.com/gg/Image-168371839287330.png">
<meta property="og:image" content="http://example.com/gg/Image-168371837218528.png">
<meta property="og:image" content="http://example.com/gg/Image-168371836380526.png">
<meta property="og:image" content="http://example.com/gg/Image-168371834833924.png">
<meta property="og:image" content="http://example.com/gg/Image-168371834454222.png">
<meta property="og:image" content="http://example.com/gg/Image-168371834012620.png">
<meta property="og:image" content="http://example.com/gg/Image-168371828315614.png">
<meta property="og:image" content="http://example.com/gg/Image-168371833190018.png">
<meta property="og:image" content="http://example.com/gg/Image-168371831922716.png">
<meta property="og:image" content="http://example.com/gg/Image-168371826967512.png">
<meta property="og:image" content="http://example.com/gg/Image-168371826519710.png">
<meta property="og:image" content="http://example.com/gg/Image-16837182584728.png">
<meta property="og:image" content="http://example.com/gg/Image-16837182527606.png">
<meta property="og:image" content="http://example.com/gg/Image-16837182469734.png">
<meta property="og:image" content="http://example.com/gg/Image-16837182330562.png">
<meta property="og:image" content="http://example.com/gg/Image.png">
<meta property="article:published_time" content="2023-05-10T08:52:56.012Z">
<meta property="article:modified_time" content="2023-05-10T11:57:37.064Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/gg/Image-168371860712372.png">
  
  
  
  <title>Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text=""></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-05-10 16:52" pubdate>
          May 10, 2023 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          21k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          173 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none"></h1>
            
            
              <div class="markdown-body">
                
                <h1 id="一-第三方登录"><a href="#一-第三方登录" class="headerlink" title="一. 第三方登录"></a>一. <strong>第三方登录</strong></h1><hr>
<ol>
<li> 应该在你的登录页面放上一个”码云登录” 的按钮</li>
<li> 点击这个按钮应该—&gt;码云登录的页面(按钮的链接就是oauth文档的步骤A)<img src="/../gg/Image-168371860712372.png" srcset="/img/loading.gif" lazyload alt="Image"></li>
<li>用户点击授权—&gt;第三方认证服务器(码云,qq)会   请求咱们设置好的回调地址请求参数携带 code  <a target="_blank" rel="noopener" href="http://127.0.0.1:9001/callback?code=f9f1da4def040151e8fc09432104d7f1a4cae17f253cf47e6da3a0c16c4464b7!%5BImage%5D(../gg/Image-168371859904370.png)">http://127.0.0.1:9001/callback?code=f9f1da4def040151e8fc09432104d7f1a4cae17f253cf47e6da3a0c16c4464b7![Image](../gg/Image-168371859904370.png)</a></li>
<li>在接口上public String callback(String code){} 拿到code</li>
<li>在步骤4的接口中,以 code,clientId,clientSerect,grant_typ,redirect_uri作为参数发送post请求–&gt;得到access_token了 (步骤D)</li>
<li> 根据access_token获取用户的信息–&gt;登录成功—&gt;跳转到登录成功页面<img src="/../gg/Image-168371858940268.png" srcset="/img/loading.gif" lazyload alt="Image"></li>
</ol>
<p><img src="/../gg/Image-168371858470966.png" srcset="/img/loading.gif" lazyload alt="Image"></p>
<h2 id="最常用的登录模式"><a href="#最常用的登录模式" class="headerlink" title="最常用的登录模式?"></a>最常用的登录模式?</h2><p>简化 、密码、授权码、客户端</p>
<p>开发人员去开放平台获取客户端id，用户带着客户端id去授权拿到code，带着code去获取access_code，用access_code去获取用户信息</p>
<h2 id="access-token-怎么续期"><a href="#access-token-怎么续期" class="headerlink" title="access_token 怎么续期?"></a>access_token 怎么续期?</h2><p>token的过期策略access_token和refresh_token的区别**</p>
<ol>
<li>access_token 的过期时间是一天(24小时)</li>
<li>refresh_token 过期时间远大于access_token</li>
<li>当 access_token 过期后，可以通过以下 refresh_token 方式重新刷新获取 access_token, 延长时间, 在登陆的时候就会生成两个token 是access_token和 refresh_token </li>
<li>如果两个都过期了就会提示重新登陆</li>
</ol>
<h1 id="二-事物的特性有哪些"><a href="#二-事物的特性有哪些" class="headerlink" title="二.事物的特性有哪些?"></a><strong>二.事物的特性有哪些?</strong></h1><hr>
<p>   1.原子性(Atomicity): 不能分割的一组操作(要么都成功,要么都失败)</p>
<p>   2.一致性(Consistency):数据要变一起变</p>
<p>   3.隔离性(Isolation): 事务与实务间相互隔离,相互不影响</p>
<p>   4.持久性(Durability):对数据造成永久的改变</p>
<p>[银行存取的例子 甲 : 转给乙100元   -100  </p>
<p>​              乙: 收到甲的100元 +100 ]</p>
<h2 id="事务的隔离级别有哪些"><a href="#事务的隔离级别有哪些" class="headerlink" title="事务的隔离级别有哪些?"></a><strong>事务的隔离级别有哪些?</strong></h2><hr>
<p>\1. READ-UNCOMMITTED(读取未提交)<strong>：</strong> 一个事务可以读取另一个事务已修改但未提交的数据, 可能会导致脏读、幻读或不可重复读。 (最低的隔离级别)</p>
<p>\2. READ-COMMITTED(读取已提交)<strong>：</strong> 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</p>
<p>\3. REPEATABLE-READ(可重复读)<strong>：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。(Mysql的默认隔离级别)</p>
<p>\4. SERIALIZABLE(可串行化)<strong>：</strong> 完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</p>
<p>(最高的隔离级别)</p>
<p><strong>优缺点</strong>: 隔离级别从上到下，并发性能越来越差，但对于数据的隔离性一致性保证程度越好</p>
<h2 id="什么是脏读-不可重复读-幻读"><a href="#什么是脏读-不可重复读-幻读" class="headerlink" title="什么是脏读 不可重复读 幻读?"></a><strong>什么是脏读 不可重复读 幻读?</strong></h2><hr>
<p><strong>脏读</strong> ： 一个事务读到另个事务已修改未提交的数据，如果前一个事务回滚，这个数据是错误的。或者在前一个事务修改之前读到了数据</p>
<p><strong>不可重复读</strong>：一个事务修改某一条数据，另一个事务在前一个事务提交之前读到的是修改前的数据，等前一个事务提交之后，读到的又是修改后的数据，造成两次读取同一条数据不一致</p>
<p><strong>幻读</strong>：某个表初始有三条数据，在一个事务中插入一条数据，另一个事务读到的也是三条数据，但是在前一个事务提交后，读到的应是4条。</p>
<h1 id="三-常见的限流算法有哪些"><a href="#三-常见的限流算法有哪些" class="headerlink" title="三.常见的限流算法有哪些?"></a><strong>三</strong>.常见的限流算法有哪些?</h1><hr>
<h2 id="1-计数限流"><a href="#1-计数限流" class="headerlink" title="1. 计数限流"></a>1. 计数限流</h2><p>​      简单的限流算法就是计数限流了，例如系统能同时处理100个请求，保存一个计数器，处理了一个请求，计数器加一，一个请求处理完毕之后计数器减一 ,每次请求来的时候看看计数器的值，如果超过阈值要么拒绝。</p>
<p>  <strong>优点</strong>: 简单粗暴</p>
<p>  <strong>缺点</strong>: 假设我们允许的阈值是1万，此时计数器的值为0， 当1万个请求在前1秒内一股       脑儿的都涌进来，这突发的流量可是顶不住的。缓缓的增加处理和一下子涌入对     于程序来说是不一样的。</p>
<h2 id="2-固定窗口限流算法"><a href="#2-固定窗口限流算法" class="headerlink" title="2. 固定窗口限流算法"></a>2. 固定窗口限流算法</h2><p> 假设我们允许的阈值是1万，此时计数器的值为0， 当1万个请         求在前1秒内一股脑儿的都涌进来，这突发的流量可是顶不住的。缓缓的增           加处理和一下子涌入对于程序来说是不一样的。</p>
<p><img src="/../gg/Image-168371857395364.png" srcset="/img/loading.gif" lazyload alt="Image"></p>
<p>​     缺点: </p>
<p>​        1.<strong>一段时间内（不超过时间窗口）系统服务不可用</strong>: 窗口大小为1s, 限流大小为100,第1s在某个窗口来了100个请求,然后第2s-999s的请求就都是被拒绝的,用户会觉得系统服务不可用.</p>
<p>​        2.<strong>窗口切换时可能会产生两倍于阈值流量的请求:</strong> 假设限流阀值为5个请求，单位时间窗口是1s,如果我们在单位时间内的前0.8-1s和1-1.2s，分别并发5个请求。虽然都没有超过阀值，但是如果算0.8-1.2s,则并发数高达10，已经超过单位时间1s不超过5阀值的定义啦，通过的请求达到了阈值的两倍.</p>
<p><img src="/../gg/Image-168371856898462.png" srcset="/img/loading.gif" lazyload alt="Image"></p>
<h2 id="3-滑动窗口限流-解决临界问题"><a href="#3-滑动窗口限流-解决临界问题" class="headerlink" title="3.滑动窗口限流:(解决临界问题)"></a>3.<strong>滑动窗口限流</strong>:(解决临界问题)</h2><p>​     记录每次请求的时间, 统计每次请求的时间 至 往前推1秒这个时间窗口内请求数，并且 1 秒前的数据可以删除。统计的请求数小于阈值就记录这个请求的时间，并允许通过，反之拒绝。 </p>
<p>​     缺点: 但是滑动窗口和固定窗口都无法解决短时间之内集中流量的突击。</p>
<p><img src="/../gg/Image-168371855618560.png" srcset="/img/loading.gif" lazyload alt="Image"></p>
<h2 id="4-漏桶算法"><a href="#4-漏桶算法" class="headerlink" title="4.漏桶算法:"></a>4.<strong>漏桶算法:</strong></h2><p>​     它的原理很简单，可以认为就是注水漏水的过程。往漏桶中以任意速率流入水，以固定的速率流出水。当水超过桶的容量时，会被溢出，也就是被丢弃。因为桶容量是不变的，保证了整体的速率。</p>
<p>​     缺点: 面对突发请求，服务的处理速度和平时是一样的，这其实不是我们想要的，在面对突发流量我们希望在系统平稳的同时，提升用户体验即能更快的处理请求，而不是和正常流量一</p>
<p><img src="/../gg/Image-168371855153558.png" srcset="/img/loading.gif" lazyload alt="Image"></p>
<h2 id="5-令牌桶算法"><a href="#5-令牌桶算法" class="headerlink" title="5.令牌桶算法:"></a>5.<strong>令牌桶算法:</strong></h2><p>​     令牌桶算法是对漏斗算法的一种改进，除了能够起到限流的作用外，还允许一定程度的流量突发。</p>
<ul>
<li>有一个令牌管理员，根据限流大小，定速往令牌桶里放令牌。</li>
<li>如果令牌数量满了，超过令牌桶容量的限制，那就丢弃。</li>
<li>系统在接受到一个用户请求时，都会先去令牌桶要一个令牌。如果拿到令牌，那么就处理这个请求的业务逻辑；</li>
<li>如果拿不到令牌，就直接拒绝这个请求。</li>
</ul>
<p><img src="/../gg/Image-168371854748556.png" srcset="/img/loading.gif" lazyload alt="Image"></p>
<p>优点: 可以看出令牌桶在应对突发流量的时候，桶内假如有 100 个令牌，那么这 100 个令牌可以马上被取走，而不像漏桶那样匀速的消费。所以在应对突发流量的时候令牌桶表现的更佳</p>
<h1 id="四-Minio上传"><a href="#四-Minio上传" class="headerlink" title="四: Minio上传"></a>四: Minio上传</h1><hr>
<p><img src="/../gg/Image-168371854322454.png" srcset="/img/loading.gif" lazyload alt="Image"></p>
<p>上传mino图片  </p>
<p>D盘软件 下有个minio.exe 执行 命令: minio.exe server D:/pic (图片地址)</p>
<h1 id="五-Autowired跟Resource"><a href="#五-Autowired跟Resource" class="headerlink" title="五. Autowired跟Resource?"></a>五. Autowired跟Resource?</h1><hr>
<ol>
<li>@Autowired：spring官方提供的一个注解，按照接口类型注入</li>
</ol>
<p>  Autowired 根据类型去找 如果想要指定可以搭配 Qualifier(value=”制定方法类名首字母小写”)</p>
<p>   \2. @Resource默认按byName自动注入。</p>
<p>七.java 8方法 </p>
<hr>
<p><img src="en-resource://database/582:0" srcset="/img/loading.gif" lazyload alt="Attachment"></p>
<p>相当于</p>
<p><img src="en-resource://database/584:0" srcset="/img/loading.gif" lazyload alt="Attachment"></p>
<h1 id="六-什么是aop"><a href="#六-什么是aop" class="headerlink" title="六. 什么是aop?"></a>六. <strong>什么是aop?</strong></h1><p>全称是Aspect Oriented Programming即：面向切面编程，把程序重复的代码抽取出来，行增强在需要执行的时候，使用动态代理的技术，在不修改源码的基础上，对我们的已有方法进强</p>
<p>Spring AOP使用的动态代理，动态代理就是说AOP框架不会去修改字节码，而是在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。</p>
<p>切面(Aspect) :共有功能的实现，日志切面，事务切面。</p>
<p>通知(Advice)：切面具体的表现，把通知事务驾到我想加的代码上(环绕通知)</p>
<p>连接点(Joinpoint)：程序运行过程中能插入切面的地点</p>
<p>切入点(Pointcut)：定义同志切入到连接点上，不同通知切入不同的点，</p>
<p>目标对象：被加入通知的对象，这些对象只有干干净净的代码</p>
<p>代理对象：通知加入对象后动态创建的对象</p>
<p>织入：就是把切面类加入到目标对象所创建新代理对象的过程就是织入</p>
<h2 id="1-AOP有什么优点"><a href="#1-AOP有什么优点" class="headerlink" title="1. AOP有什么优点"></a>1. <strong>AOP有什么优点</strong></h2><p>1、减少重复代码</p>
<p>2、提高开发效率</p>
<p>3、维护方便</p>
<h2 id="2-AOP环绕通知"><a href="#2-AOP环绕通知" class="headerlink" title="2. AOP环绕通知"></a><strong>2. AOP环绕通知</strong></h2><p>总结：</p>
<p>1、前置通知：在切入点方法之前执行</p>
<p>2、后置通知：在切入点方法之后通知</p>
<p>3、异常通知：在执行切入点方法过程中出现异常后执行（因此异常通知和后置通知只能执行一个）</p>
<p>4、最终通知：无论切入点方法是否正常执行它都会执行</p>
<p>5、环绕通知：当配置环绕通知之后，在环绕通知里面必须要明确调用业务层的方法，如果不调用，就会出现只出现通知，而不执行方法</p>
<h2 id="3-aop逻辑："><a href="#3-aop逻辑：" class="headerlink" title="3**.** aop逻辑："></a>3**.** aop<strong>逻辑：</strong></h2><p><strong>AOP实现，通过后置通知，异常通知来创建记录日志的任务，交给线程池执行。</strong></p>
<h2 id="4-Spring-AOP使用的动态代理"><a href="#4-Spring-AOP使用的动态代理" class="headerlink" title="4. Spring AOP使用的动态代理"></a>4. Spring AOP使用的动态代理</h2><p>动态代理就是说AOP框架不会去修改字节码，而是在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。</p>
<h1 id="七、前置、后置处理器（扩展Spring）"><a href="#七、前置、后置处理器（扩展Spring）" class="headerlink" title="七、前置、后置处理器（扩展Spring）"></a><strong>七、前置、后置处理器（扩展Spring）</strong></h1><p>前置处理器：实例化bean之前, BeanFactoryPostProcess接口 </p>
<p>后置处理器：实例化bean之后, BeanPostProcessor接口</p>
<h1 id="八-vue脚手架"><a href="#八-vue脚手架" class="headerlink" title="八.vue脚手架"></a><strong>八.vue脚手架</strong></h1><p><strong>vue 脚手架2 启动npm run serve 脚手架3是 npm run dev</strong></p>
<hr>
<h1 id="九-总结一下HashSet和HashMap的区别"><a href="#九-总结一下HashSet和HashMap的区别" class="headerlink" title="九.总结一下HashSet和HashMap的区别:"></a><strong>九.总结一下HashSet和HashMap的区别:</strong></h1><p>(1)HashSet实现了Set接口, 仅存储对象; HashMap实现了 Map接口, 存储的是键值对.</p>
<p>(2)HashSet底层其实是用HashMap实现存储的, HashSet封装了一系列HashMap的方法. 依靠HashMap来存储元素值,(利用hashMap的key键进行存储), 而value值默认为Object对象. 所以HashSet也不允许出现重复值, 判断标准和HashMap判断标准相同, 两个元素的hashCode相等并且通过equals()方法返回true.</p>
<hr>
<h1 id="十-Java中ArrayList与LinkedList的区别"><a href="#十-Java中ArrayList与LinkedList的区别" class="headerlink" title="十.Java中ArrayList与LinkedList的区别"></a>十.<strong>Java中ArrayList与LinkedList的区别</strong></h1><p> \1. ArrayList的实现是基于数组，LinkedList的实现是基于双向链表。 </p>
<p>   \2. 对于随机访问，ArrayList优于LinkedList</p>
<p>   \3. 对于插入和删除操作，LinkedList优于ArrayList  </p>
<p>　　4. LinkedList比ArrayList更占内存，因为LinkedList的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。</p>
<p>​     5.ArrayList的空间浪费主要体现lsit列表结尾会预留一定容量空间，而linkedlist的空间花费体现每一个元素都需要消耗比ArrayList更多空间,因为要存放直接后继和直接前驱以及数据</p>
<hr>
<h1 id="十二-Set和list-的区别？"><a href="#十二-Set和list-的区别？" class="headerlink" title="十二. Set和list 的区别？"></a><strong>十二. Set和list 的区别？</strong></h1><p><strong>(都可存储null值 单set不能重复)</strong></p>
<p>Set: 无序不重复 效率低，增删快，</p>
<p>list: 有序可重复 和数组相似，根据数据自动增长，查找快，增删慢</p>
<hr>
<h1 id="十三-ArrayList-和Vector区别"><a href="#十三-ArrayList-和Vector区别" class="headerlink" title="十三.  ArrayList 和Vector区别?"></a><strong>十三.  ArrayList 和Vector区别?</strong></h1><p>ArrayList :线程不安全，单线程最好使用</p>
<p>Vector:线程安全的,线程同步,多线程访问最好使用</p>
<hr>
<h1 id="十四-HaspMap与TreeMap的区别"><a href="#十四-HaspMap与TreeMap的区别" class="headerlink" title="十四.  HaspMap与TreeMap的区别?"></a><strong>十四.  HaspMap与TreeMap的区别?</strong></h1><p>hashmap通过hashcode快速查找</p>
<p>treemap: 有序集合</p>
<hr>
<h1 id="十五-Collection和Collections的区别"><a href="#十五-Collection和Collections的区别" class="headerlink" title="十五.  Collection和Collections的区别?"></a><strong>十五.  Collection和Collections的区别?</strong></h1><p>Collection是单列集合的顶层接口，Map是双列接口，</p>
<p>Collections是一个集合工具类，提供排序查找操作集合常用方法</p>
<hr>
<hr>
<h2 id="List-get-0-操作"><a href="#List-get-0-操作" class="headerlink" title="List.get(0)操作"></a><strong>List.get(0)操作</strong></h2><p>在平时查询操作时，因为查询出查询的字段是唯一的，但mybatis如果不是查主键，没有设定查唯一字段，而返回一个对象，也是返回一个List，但List只包含一个对象，所以这时会用到会用到List.get(0)。</p>
<p>在做这这步操作时，要注意判断List.size()是否大于0，如果=0，则会报异常。</p>
<hr>
<h1 id="十六-mybatis常用标签"><a href="#十六-mybatis常用标签" class="headerlink" title="十六.  mybatis常用标签"></a><strong>十六.  mybatis常用标签</strong></h1><p><strong>select</strong> 标签</p>
<p><strong>id</strong> :   唯一的标识符.</p>
<p><strong>parameterType</strong>:传给此语句的参数的全路径名或别名 例:com.test.poso.User或user</p>
<p><strong>resultType</strong> :语句返回值类型或别名。注意，如果是集合，那么这里填写的是集合的泛型，而不是集合本身（resultType 与resultMap 不能并用）</p>
<p><strong>insert 标签</strong></p>
<p><strong>delete 标签</strong></p>
<p><strong>update 标签</strong> </p>
<p><strong>if 标签</strong> if标签通常用于WHERE语句、UPDATE语句、INSERT语句中，通过判断参数值来决定是否使用某个查询条件、判断是否更新某一个字段、判断是否插入某个字段的值。</p>
<p><strong>foreach标签</strong> foreach标签主要用于构建in条件，可在sql中对集合进行迭代。也常用到批量删除、添加等操作中。</p>
<p><strong>collection</strong>：collection属性的值有三个分别是list、array、map三种，分别对应的参数类型为：List、数组、map集合。</p>
<p><strong>item</strong> ：表示在迭代过程中每一个元素的别名</p>
<p><strong>index</strong> ：表示在迭代过程中每次迭代到的位置（下标）</p>
<p><strong>open</strong> ：前缀</p>
<p><strong>close</strong> ：后缀</p>
<p><strong>separator</strong> ：分隔符，表示迭代时每个元素之间以什么分隔</p>
<p><strong>choose标签</strong></p>
<p><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=MyBatis&spm=1001.2101.3001.7020">MyBatis</a>提供了choose 元素，按顺序判断when中的条件出否成立，如果有一个成立，则choose结束。当choose中所有when的条件都不满则时，则执行 otherwise中的sql。类似于Java 的switch 语句，choose为switch，when为case，otherwise则为default。</p>
<p>if是与(and)的关系，而choose是或（or）的关系。</p>
<p><strong>where标签</strong></p>
<p><strong>include标签</strong> 用于引用定义的常量</p>
<p><strong>sql标签</strong></p>
<p>当多种类型的查询语句的查询字段或者查询条件相同时，可以将其定义为常量，方便调用。为求<select>结构清晰也可将sql语句分解。</p>
<hr>
<h1 id="十七-springMvc常用注解"><a href="#十七-springMvc常用注解" class="headerlink" title="十七. springMvc常用注解"></a><strong>十七. springMvc常用注解</strong></h1><p><strong>@Controller注解</strong></p>
<p>该注解用来标记类，由其标记的类就是一个Spring MVC Controller的一个对象，即一个控制器类。</p>
<p>Spring使用扫描机制扫描应用程序中所有使用该注解进行注释的类，分发处理器扫描使用了该注解的类的方法，检测方法是否使用了@RequestMapping注解，使用了@RequestMapping注解的方法才是真正处理请求的处理器。</p>
<h2 id="1-RequestMapping"><a href="#1-RequestMapping" class="headerlink" title="1. @RequestMapping"></a><strong>1. @RequestMapping</strong></h2><p>该注解用来标记类或者方法，指示Spring用该类或者方法处理请求动作。</p>
<ul>
<li>value: 指定接收的路径</li>
<li>method: 接收什么请求（get repost…）</li>
<li>params： 对参数的限制</li>
<li>headers: 浏览器的请求头</li>
</ul>
<h2 id="2-RequestParam"><a href="#2-RequestParam" class="headerlink" title="2.@RequestParam"></a>2.@RequestParam</h2><p> 该注解用来将指定的请求参数赋值给方法中的形参。</p>
<ul>
<li>name： 浏览器中的key</li>
<li>defaultValue: 默认值</li>
<li>required: 参数是否必须传</li>
</ul>
<h2 id="3-RequestHeader"><a href="#3-RequestHeader" class="headerlink" title="3.@RequestHeader"></a>3.@RequestHeader</h2><p>获取请求头信息</p>
<h2 id="5-ResponseBody"><a href="#5-ResponseBody" class="headerlink" title="5.@ResponseBody"></a><strong>5.@ResponseBody</strong></h2><p>返回 jackson对象，需要导入依赖 jackson-databind</p>
<h2 id="6-RequestBody"><a href="#6-RequestBody" class="headerlink" title="6.@RequestBody"></a><strong>6.@RequestBody</strong></h2><p>接收前端传过来的json对象</p>
<h2 id="7-ModelAttribute"><a href="#7-ModelAttribute" class="headerlink" title="7.@ModelAttribute"></a><strong>7.@ModelAttribute</strong></h2><p>加在方法上，该方法为公共方法，对当前controller的请求都会被该方法处理，且可以返回值，默认以返回值类型的简单名称为key,以返回值为value, 可以通过name属性指定key</p>
<p>加在参数上，可以接收地址栏上的参数</p>
<h2 id="8-PathVariable"><a href="#8-PathVariable" class="headerlink" title="8.@PathVariable"></a><strong>8.@PathVariable</strong></h2><p>取出请求中占位符对应的参数</p>
<p><img src="/../gg/Image-168371851582052.png" srcset="/img/loading.gif" lazyload alt="Image"></p>
<hr>
<h1 id="十八-多线程"><a href="#十八-多线程" class="headerlink" title="十八. 多线程?"></a><strong>十八. 多线程?</strong></h1><h2 id="进程、线程、并行、并发"><a href="#进程、线程、并行、并发" class="headerlink" title="进程、线程、并行、并发"></a>进程、线程、并行、并发</h2><p> 程序: 软件, 工程</p>
<p> 进程: 正在运行的程序</p>
<p> 线程: 进程中的任务单位</p>
<p> CPU 可以”同时”处理多个线程</p>
<p> 并行: 同一时刻, 同时运行, 通常需要多核处理器</p>
<p> 并发: 多线程, 交替执行(交替速度足够快, 看起来是同时)(同一时间段发生)</p>
<p>实现多线程:</p>
<p> main -&gt; 一个线程</p>
<p> 执行多线程: 随机性</p>
<h2 id="线程的创建方式"><a href="#线程的创建方式" class="headerlink" title="线程的创建方式?"></a>线程的创建方式?</h2><p> <strong>方式一: 只能继承一个类, 功能性单一</strong></p>
<p>  1.自定义类, 继承Thread</p>
<p>  2.重写run方法</p>
<p>  3.在主程序中创建线程对象</p>
<p>  4.开启线程 start()</p>
<p> <strong>方式二: 实现接口 runnable()</strong></p>
<p>  1.自定义类, 实现Runnable接口</p>
<p>  2.实现run方法</p>
<p>  3.创建线程对象 ※ 使用Runnable对象来构造</p>
<p>  4.开启线程 start</p>
<p> <strong>方式三: 匿名内部类</strong></p>
<p>Thread 基础的API:</p>
<p> String getName(): Thread 属性 name</p>
<p> static Thread currentThread(): 获得当前线程对象</p>
<p> static void sleep(long time): 当前线程的阻塞时间</p>
<p>线程安全: 多个线程共享资源</p>
<p>解决安全: 实现线程同步</p>
<p>​     加锁: 同步锁 synchronized, 需要借助一个对象</p>
<p>​       Lock锁 接口 实现类 ReentrantLock()</p>
<p>​         上锁 lock() 解锁 unlock()</p>
<p><strong>线程其他属性和方法:</strong></p>
<p>  setPriority(1-10越来越大): 设置优先级, 提升了这个线程的执行概率</p>
<p>  setDaemon(true): 设置守护线程, 所有的”前置”线程结束, 守护线程也将自动结束</p>
<p>​           GC -&gt; 垃圾回收(守护线程)</p>
<p>​           System.gc() -&gt; 手动清理</p>
<h2 id="线程的三大特性"><a href="#线程的三大特性" class="headerlink" title="线程的三大特性?"></a>线程的三大特性?</h2><p><strong>原子性</strong>  所谓原子性就是指一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p>
<p> <strong>可见性</strong> 可见性是指多个线程访问一个资源时，该资源的状态、值信息等对于其他线程都是可见的。</p>
<p><strong>有序性:</strong> 有序性值程序执行的顺序按照代码先后执行。</p>
<hr>
<h2 id="实现-Runnable-接⼝⽐继承-Thread-类所具有的优势："><a href="#实现-Runnable-接⼝⽐继承-Thread-类所具有的优势：" class="headerlink" title="实现 Runnable 接⼝⽐继承 Thread 类所具有的优势："></a><strong>实现 Runnable 接⼝⽐继承 Thread 类所具有的优势：</strong></h2><p>\1. 适合多个相同的程序代码的线程去共享同⼀个资源。</p>
<p>\2. 可以避免 java 中的单继承的局限性。</p>
<p>\3. 增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独⽴。</p>
<p>\4. 线程池只能放⼊实现 Runable 或 Callable 类线程，不能直接放⼊继承 Thread 的类。</p>
<hr>
<h2 id="Runnable和Callable的区别："><a href="#Runnable和Callable的区别：" class="headerlink" title="Runnable和Callable的区别："></a><strong>Runnable和Callable的区别：</strong></h2><ul>
<li>1、Callable规定的方法是call(),Runnable规定的方法是run().</li>
<li>2、Callable的任务执行后可返回值，而Runnable的任务是不能返回值得</li>
<li>3、call方法可以抛出异常，run方法不可以</li>
<li>4、运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。</li>
</ul>
<hr>
<h2 id="synchronized同步锁"><a href="#synchronized同步锁" class="headerlink" title="synchronized同步锁"></a><strong>synchronized同步锁</strong></h2><p>synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p>
<hr>
<p>CAS是英文单词CompareAndSwap的缩写，中文意思是：比较并替换。</p>
<p><strong>同步代码块：</strong> synchronized 关键字可以⽤于⽅法中的某个区块中，表示只对这个区块的资源实⾏互斥访问</p>
<p>同步锁： 对象的同步锁只是⼀个概念，可以想象为在对象上标记了⼀个锁。</p>
<p>\1. 锁对象，可以是任意类型。</p>
<p>\2. 多个线程对象，要使⽤同⼀把锁。</p>
<hr>
<p><strong>同步⽅法</strong> <strong>使⽤</strong> synchronized 修饰的⽅法，就叫做同步⽅法，保证A线程执⾏该⽅法的时候，其他线程只能在⽅法外等着。</p>
<p>网址: <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_51182368/article/details/125799573">(3条消息) 什么是线程？线程概念及方法详细讲解_Sion. Z的博客-CSDN博客</a></p>
<hr>
<h2 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a><strong>Lock锁</strong></h2><p>java.util.concurrent.locks.Lock 机制提供了⽐ synchronized 代码块和 synchronized ⽅法更⼴泛的</p>
<p>锁定操作，同步代码块 / 同步⽅法具有的功能 Lock 都有，除此之外更强⼤，更体现⾯向对象。</p>
<p>Lock 锁也称同步锁，创建对象 Lock lock = new ReentrantLock() ，加锁与释放锁⽅法如下：</p>
<p>public void lock() ：加同步锁。</p>
<p>public void unlock() ：释放同步锁。</p>
<h1 id="十九、线程池？"><a href="#十九、线程池？" class="headerlink" title="十九、线程池？"></a>十九、线程池？</h1><p><strong>Java线程池(围绕ThreadPoolExecutor讲解工作流程、常见参数、调优、监控****）</strong></p>
<h4 id="1-Java的线程池"><a href="#1-Java的线程池" class="headerlink" title="1. Java的线程池"></a><strong>1. Java的</strong><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%BA%BF%E7%A8%8B%E6%B1%A0&spm=1001.2101.3001.7020">线程池</a></h4><h5 id="①-合理使用线程池的好处"><a href="#①-合理使用线程池的好处" class="headerlink" title="① 合理使用线程池的好处"></a>① 合理使用线程池的好处</h5><ul>
<li><p>Java的线程池是运用场景最多的并发框架，几乎所有需要异步或者并发执行任务的程序都可以使用线程池。</p>
</li>
<li><ul>
<li><strong>降低资源消耗</strong>。 通过重复利用已经创建的线程降低线程创建的和销毁造成的消耗。例如，工作线程Woker会无线循环获取阻塞队列中的任务来执行。</li>
<li><strong>提高响应速度</strong>。 当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>。 线程是稀缺资源，Java的线程池可以对线程资源进行统一分配、调优和监控。</li>
<li></li>
</ul>
</li>
</ul>
<h5 id="②-线程池的工作流程"><a href="#②-线程池的工作流程" class="headerlink" title="② 线程池的工作流程"></a><strong>② 线程池的工作流程</strong></h5><p><strong>一个新的任务到线程池时，线程池的处理流程如下：</strong></p>
<ul>
<li><strong>线程池判断核心线程池里的线程是否都在执行任务。</strong> 如果不是，创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。</li>
<li><strong>线程池判断阻塞队列是否已满</strong>。 如果阻塞队列没有满，则将新提交的任务存储在阻塞队列中。如果阻塞队列已满，则进入下个流程。</li>
<li><strong>线程池判断线程池里的线程是否都处于工作状态</strong>。 如果没有，则创建一个新的工作线程来执行任务。如果已满，则交给饱和策略来处理这个任务。</li>
<li><img src="/../gg/Image-168371843142942.png" srcset="/img/loading.gif" lazyload alt="Image"></li>
</ul>
<p><img src="/../gg/Image-168371842789540.png" srcset="/img/loading.gif" lazyload alt="Image"></p>
<h5 id="线程池的关闭（shutdown或者shutdownNow方法）"><a href="#线程池的关闭（shutdown或者shutdownNow方法）" class="headerlink" title="线程池的关闭（shutdown或者shutdownNow方法）"></a><strong>线程池的关闭（<strong><strong>shutdown或者shutdownNow方法</strong></strong>）</strong></h5><ol>
<li><p>shutdown方法将线程池的状态设置为SHUTDOWN状态，<strong>只会中断空闲的工作线程</strong>。</p>
</li>
<li><p>shutdownNow方法将线程池的状态设置为STOP状态，<strong>会中断所有工作线程</strong>，不管工作线程是否空闲。</p>
</li>
<li><p><strong>任务的性质：</strong> CPU 密集型任务(计算型)、IO 密集型任务(读写)和混合型任务。</p>
</li>
<li><p><strong>任务的优先级：</strong> 高、中、低。</p>
</li>
<li><p><strong>任务的执行时间：</strong> 长、中、短。</p>
</li>
<li><p><strong>任务;的依赖性：</strong> 是否依赖其他系统资源，如数据库连接。</p>
</li>
<li><p><strong>线程池****五个状态的特点</strong>以及如何进行状态之间的切换：</p>
</li>
</ol>
<p><strong>RUNNING</strong><strong>:</strong> 该状态的线程池<strong>既能接受新提交的任务</strong>，<strong>又能处理阻塞队列中任务</strong>。</p>
<p><strong>shutdown</strong> <strong>:<strong>该状态的线程池</strong>不能接收新提交的任务</strong>，但是<strong>能处理阻塞队列中的任务</strong>。(不接收新的任务了,处理完已经手里有任务的 ,就下班)</p>
<p><strong>stop:</strong> <strong>：</strong> 该状态的线程池<strong>不接受新提交的任务</strong>，也<strong>不处理在阻塞队列中的任务</strong>，<strong>还会中断正在执行的任务</strong>。(不管手机是否有任务 都中断 下班!)</p>
<p><strong>tidying：</strong> 如果所有的任务都已终止，workerCount (有效线程数)=0 。</p>
<p><strong>terminated：</strong> 在terminated()钩子方法执行完后进入该状态，<strong>默认<strong><strong>terminated()钩子方法</strong></strong>中什么也没有做</strong>。</p>
<h2 id="线程池的作用？"><a href="#线程池的作用？" class="headerlink" title="线程池的作用？"></a>线程池的作用？</h2><p> <strong>1.降低线程创建和销毁的开销</strong></p>
<p>线程的创建和销毁都需要一定的系统开销，如果频繁地创建和销毁线程，会导致系统开销增加，影响程序的性能。使用线程池可以减少线程的创建和销毁次数，从而降低开销。</p>
<p><strong>2.提高程的复用性</strong>**</p>
<p>线程池中的线程可以被多个任务重复利用，从而提高线程的复用性，减少线程的竞争和冲突。</p>
<p>   <strong>3. 控制并发线程的数量</strong></p>
<p>​     线程池可以控制同时运行的线程数量，从而避免由于线程数量过多而导致系统资源不足、程序运行变慢等问题。</p>
<p> <strong>4. 提高系统的稳定性</strong></p>
<hr>
<p><img src="/../gg/Image-168371850197550.png" srcset="/img/loading.gif" lazyload alt="Image"></p>
<hr>
<h1 id="二十-RocketMQ-和-RabbitMQ-的区别，消息队列"><a href="#二十-RocketMQ-和-RabbitMQ-的区别，消息队列" class="headerlink" title="二十. RocketMQ 和 RabbitMQ 的区别，消息队列?"></a><strong>二十. RocketMQ 和 RabbitMQ 的区别，消息队列?</strong></h1><p>简介:</p>
<p><strong>1. RabbitMQ</strong></p>
<p>是基于AMQP (高级消息队列协议) 协议的 具有跨语言的特性，支持多种开发语言,基于erlang语言编写,天生具有高并发.( erlang是通用的面向并发的编程语言)</p>
<p><strong>2. rocketMQ</strong></p>
<p>是基于JMS的 是阿里巴巴旗下开发的mq,现在可以多语言接入,声称可用性极高</p>
<p><strong>3.Kafka</strong></p>
<p>kafka是一个分布式、高吞吐量、高扩展性的消息队列系统。kafka最初是由Linkedin公司开发的，后来在2010年贡献给了Apache基金会，成为了一个开源项目。主要应用在日志收集系统和消息系统</p>
<p><strong>4.</strong> <strong>ActiveMQ</strong></p>
<p>Apache旗下的老牌消息引擎</p>
<h2 id="2-多个MQ如何选型"><a href="#2-多个MQ如何选型" class="headerlink" title="2.多个MQ如何选型?"></a><strong>2.多个MQ如何选型?</strong></h2><p><img src="/../gg/Image-168371849503648.png" srcset="/img/loading.gif" lazyload alt="Image"></p>
<h2 id="3-为什么要是用MQ"><a href="#3-为什么要是用MQ" class="headerlink" title="3.为什么要是用MQ?"></a><strong>3.为什么要是用MQ?</strong></h2><p><img src="/../gg/Image-168371848032546.png" srcset="/img/loading.gif" lazyload alt="Image"></p>
<p>3.</p>
<p>AbortPolicy（默认）：丢弃任务并抛出 RejectedExecutionException 异常。</p>
<p>CallerRunsPolicy：由调用线程处理该任务。</p>
<p>DiscardPolicy：丢弃任务，但是不抛出异常。可以配合这种模式进行自定义的处理方式。</p>
<p>DiscardOldestPolicy：丢弃队列最早的未处理任务，然后重新尝试执行任务。</p>
<h2 id="1-RocketMQ和RabbitMQ的区别"><a href="#1-RocketMQ和RabbitMQ的区别" class="headerlink" title="1.RocketMQ和RabbitMQ的区别?"></a><strong>1.RocketMQ和RabbitMQ的区别?</strong></h2><ol>
<li><p>语言支持：RocketMQ使用Java编写，而RabbitMQ使用Erlang编写。</p>
</li>
<li><p>性能：RocketMQ在性能上比RabbitMQ更优秀，主要体现在消息吞吐量、延迟和稳定性方面。</p>
</li>
<li><p>社区支持：RabbitMQ的社区比RocketMQ更加活跃，具有更多的插件和扩展功能。</p>
</li>
<li><p>总的来说，RocketMQ适用于高性能、高可靠性、海量消息传递场景，而RabbitMQ则更适合于异构系统之间的消息传递。</p>
</li>
</ol>
<h2 id="2-RocketMQ-Broker中的消息被消费后会立即删除吗？"><a href="#2-RocketMQ-Broker中的消息被消费后会立即删除吗？" class="headerlink" title="2.RocketMQ Broker中的消息被消费后会立即删除吗？"></a>2.<strong>RocketMQ Broker中的消息被消费后会立即删除吗？</strong></h2><p>不会，每条消息都会持久化到CommitLog中，每个Consumer连接到Broker后会维持消费进度信息，当有消息消费后只是当前Consumer的消费进度（CommitLog的offset）更新了。</p>
<h2 id="3-那么消息会堆积吗？什么时候清理过期消息？"><a href="#3-那么消息会堆积吗？什么时候清理过期消息？" class="headerlink" title="**3.**那么消息会堆积吗？什么时候清理过期消息？"></a>**3.**<strong>那么消息会堆积吗？什么时候清理过期消息？</strong></h2><p>4.6版本默认48小时后会删除不再使用的CommitLog文件</p>
<ul>
<li>检查这个文件最后访问时间</li>
<li>判断是否大于过期时间</li>
<li>指定时间删除，默认凌晨4点</li>
</ul>
<h2 id="4、RocketMQ消费模式有几种？"><a href="#4、RocketMQ消费模式有几种？" class="headerlink" title="4、RocketMQ消费模式有几种？"></a><strong>4、RocketMQ消费模式有几种？</strong></h2><p>消费模型由Consumer决定，消费维度为Topic。</p>
<p><strong>集群消费</strong>:  一条同时消费一个 消息只会被同group的consumer消费</p>
<p>​         多个group同时消费一个topic，每个group都会有一个consumer消费到数据</p>
<p><strong>广播消费</strong>: 消息对consumer group下的 各个consumer消费一遍，即使同属于一个组，也会把每个consumer消费一次</p>
<h2 id="5-消费消息是push还是pull？"><a href="#5-消费消息是push还是pull？" class="headerlink" title="5.消费消息是push还是pull？"></a><strong>5.消费消息是push还是pull？</strong></h2><p>Rockermq没有真正的push，都是pull，虽然有push类，但是底层采用的是长轮训机制，即拉取方式</p>
<h2 id="6、RocketMQ如何保证消息不丢失？"><a href="#6、RocketMQ如何保证消息不丢失？" class="headerlink" title="6、RocketMQ如何保证消息不丢失？"></a><strong>6、RocketMQ如何保证消息不丢失？</strong></h2><p><strong>Producer端</strong>:   </p>
<ol>
<li><p> 采取send()同步发消息，发送结果是同步感知的                    </p>
</li>
<li><p>发送失败后可以重试，设置重试次数。默认3次。                 </p>
</li>
</ol>
<p>​       集群部署，比如发送失败了的原因可能是当前Broker宕机了，重试的时候               会发送到其他Broker上。</p>
<p><strong>Broker端</strong>   </p>
<p>​    1.修改刷盘策略为同步刷盘。默认情况下是异步刷盘的。</p>
<p>​    2.集群部署，主从模式，高可用。</p>
<p><strong>Consumer端</strong> </p>
<p> 1.完全消费正常后在进行手动ack(消息确认机制)确认。</p>
<hr>
<h1 id="二一、面向对象的三个基本特征"><a href="#二一、面向对象的三个基本特征" class="headerlink" title="二一、面向对象的三个基本特征:"></a>二一、面向对象的三个基本特征:</h1><p><strong>面向对象的特征：封装、继承、多态、抽象。</strong></p>
<p><strong>封装</strong>：就是把对象的属性和行为（数据）结合为一个独立的整体，并尽可能隐藏对象的内部实现细节，就是把不想告诉或者不该告诉别人的东西隐藏起来，把可以告诉别人的公开，别人只能用我提供的功能实现需求，而不知道是如何实现的。增加安全性。</p>
<p><strong>继承</strong>：子类继承父类的数据属性和行为，并能根据自己的需求扩展出新的行为，提高了代码的复用性。</p>
<p><strong>多态</strong>：指允许不同的对象对同一消息做出相应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式（发送消息就是函数调用）。封装和继承几乎都是为多态而准备的，在执行期间判断引用对象的实际类型，根据其实际的类型调用其相应的方法。</p>
<p><strong>抽象</strong>表示对问题领域进行分析、设计中得出的抽象的概念，是对一系列看上去不同，但是本质上相同的具体概念的抽象。在Java中抽象用 abstract 关键字来修饰，用 abstract 修饰类时，此类就不能被实例化，从这里可以看出，抽象类（接口）就是为了继承而存在的。</p>
<p><strong>抽象</strong>: 抽象方法就是以abstract修饰的方法<strong>，**<strong>没有方法体,只声明</strong></strong>,,**抽象类不能直接实例化 ，可以包含抽象方法 。 </p>
<p>   抽象类不能用final来修饰，即一个类不能既是最终类又是抽象类。</p>
<p>   abstract不能与private、static、final、native并列修饰同一个方法。</p>
<p><strong>多态:</strong> 指允许不同的对象对同一消息做出相应,比如 人 变成男人和女人</p>
<p><strong>继承:</strong> 子类继承父类的数据属性和行为 ,子类继承父类的数据属性和行为</p>
<p><strong>封装:</strong> 把对象的属性和行为结合成一个独立的整体 , 隐藏细节 ,别人可以直接调用方法,但是不知道具体实现过程，提高了安全性</p>
<hr>
<h1 id="二二、什么是重写和重载"><a href="#二二、什么是重写和重载" class="headerlink" title="二二、什么是重写和重载?"></a>二二、什么是重写和重载?</h1><p><strong>重载：</strong> 同一个类里,方法名相同，参数类型、个数、顺序不同 </p>
<p><strong>重写:</strong>  子类重写父类的方法，但是范围姚晓宇弗雷德范围，如果父类修饰符为private 那就不能重写</p>
<hr>
<h1 id="二三-MangoDB"><a href="#二三-MangoDB" class="headerlink" title="二三.MangoDB"></a>二三.<strong>MangoDB</strong></h1><p>Mongodb是非关系型数据库(nosql ),属于文档型数据库。</p>
<p><img src="/../gg/Image-168371844615744.png" srcset="/img/loading.gif" lazyload alt="Image"></p>
<hr>
<h1 id="二四-Java中-和equals的区别"><a href="#二四-Java中-和equals的区别" class="headerlink" title="二四.Java中==和equals的区别"></a>二四.<strong>Java中==和equals的区别</strong></h1><p>==的作用 : 基本类型，比较值 是否相同</p>
<p>​           引用类型，比较地址是否相同</p>
<p>equals: 引用类型,默认情况下 比较地址 （堆内存）是否想同 ,如果用 String，Integer,Date 用equals 那就是比较的内容 </p>
<hr>
<h1 id="二五-String-StringBuffer-StringBuilder的区别"><a href="#二五-String-StringBuffer-StringBuilder的区别" class="headerlink" title="二五.String,StringBuffer,StringBuilder的区别"></a><strong>二五.String,StringBuffer,StringBuilder的区别</strong></h1><p>String 操作量少地方话可以使用 </p>
<p>StringBuffer 同步锁 线程安全 多线程 使用</p>
<p>StringBuilder 没有同步锁 非线程安全 单线程不</p>
<hr>
<h1 id="二六-接口和抽象类区别"><a href="#二六-接口和抽象类区别" class="headerlink" title="二六*.接口和抽象类区别?*"></a>二六*.<em>接口和抽象类区别?</em>*</h1><p>抽象类 的子类使用extend的继承 用implements实现接口</p>
<p>构造函数 抽象类有构造函数 接口没有</p>
<p>main方法 抽象类有main方法 接口没有main方法</p>
<p>实现数量  类可以实现很多个接口 但是只能继承一个抽象类</p>
<p>访问修饰符 接口默认public修饰 抽象类 可以任意访问</p>
<hr>
<h1 id="二七、-什么是单例模式"><a href="#二七、-什么是单例模式" class="headerlink" title="二七、.什么是单例模式?"></a>二七、.<strong>什么是单例模式?</strong></h1><p>创建类时只能存在一个实例，并且在类只提供一个取得其对象实例的方法(静态)</p>
<h2 id="单例模式的三种模式"><a href="#单例模式的三种模式" class="headerlink" title="单例模式的三种模式?"></a><strong>单例模式的三种模式?</strong></h2><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式:"></a><strong>饿汉式:</strong></h2><p>在刚创建时就直接实例化 ，构造器私有化，对外用静态方法暴露</p>
<p>**优点:**写法简单 创建时就实例化，避免线程同步，线程安全</p>
<p><strong>缺点:</strong> 类装载时实例化，没用到lazy loading的效果(延迟到用的时候加载) 如果未使用，内存浪费</p>
<p><img src="/../gg/Image-168371841326638.png" srcset="/img/loading.gif" lazyload alt="Image"></p>
<p><strong>静态代码块</strong></p>
<p>把类实例化放到静态代码块写 ,跟上面一样</p>
<p><img src="/../gg/Image-168371840807636.png" srcset="/img/loading.gif" lazyload alt="Image"></p>
<h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式:"></a>懒汉式:</h2><p><strong>在需要调用时候创建类的 实例化</strong></p>
<p><strong>线程不安全:</strong> 起到懒加载效果，只能单线程使用，多线程会不安全,创建多个实例化对象</p>
<p><img src="/../gg/Image-168371840115234.png" srcset="/img/loading.gif" lazyload alt="Image"></p>
<p>**线程安全:**就是加了一个同步锁synchronized ，降低效率</p>
<p><img src="/../gg/Image-168371839762232.png" srcset="/img/loading.gif" lazyload alt="Image"></p>
<h2 id="双重检查"><a href="#双重检查" class="headerlink" title="双重检查:"></a><strong>双重检查</strong>:</h2><p>** 在同步前判断下有没有实例化，没有实例化就new一个，否则return，这就是双重检查，用到了volatile，防指指令重排，如果不用会和线程不安全情形一样，在if那有并发</p>
<p>(实现了懒加载，保证线程安全)</p>
<p><img src="/../gg/Image-168371839287330.png" srcset="/img/loading.gif" lazyload alt="Image"></p>
<hr>
<h1 id="二八、-HashMap的总结"><a href="#二八、-HashMap的总结" class="headerlink" title="二八、.HashMap的总结?"></a>二八、.HashMap的总结?</h1><h2 id="1-HashMap的底层数据结构"><a href="#1-HashMap的底层数据结构" class="headerlink" title="1.HashMap的底层数据结构?"></a>1.<strong>HashMap的底层数据结构?</strong></h2><p>hashmap的底层实现数据结构为数组+链表的形式，jdk1.8之后就变成了数组+链表+红黑树，为了解决查询效率变慢的问题。</p>
<hr>
<h2 id="2-HashMap的工作原理"><a href="#2-HashMap的工作原理" class="headerlink" title="2.HashMap的工作原理?"></a>2.<strong>HashMap的工作原理?</strong></h2><p>HashMap底层是hash数组和单向链表实现,数组中的每个元素都是链表,由Node内部类(实现Map.Entry&lt;K,V&gt;接口)实现,HashMap通过put&amp;get方法存储和获取。</p>
<p>数组是hashmap的主体，链表主要是为了解决哈希冲突而存在的，hashmap是通过key的hashcode来计算得到的hash值，然后通过位运算判断当前元素存放的位置，如果位置存放元素，就判断元素与要存入的hash值和key是否相同，如果相同的话，直接覆盖，不同就通过拉链法解决冲突。map总数超过数组的0.75，触发扩容，为了减少链表长度，元素分配更均匀。</p>
<p>(JDK1.7之前使用头插法、JDK1.8使用尾插法)</p>
<hr>
<h2 id="3-为什么会哈希冲突？"><a href="#3-为什么会哈希冲突？" class="headerlink" title="3.为什么会哈希冲突？"></a>3.<strong>为什么会哈希冲突？</strong></h2><p>hashmap主要是通过key的hashcode来计算的，只要hashcode相同，计算出来的hash值就一样。如果存储对象多了，就有可能不同的对象算出来的hash值是相同的，这就是hash冲突。</p>
<hr>
<h2 id="4-哈希冲突及解决办法"><a href="#4-哈希冲突及解决办法" class="headerlink" title="4.哈希冲突及解决办法?"></a>4.<strong>哈希冲突及解决办法?</strong></h2><p>1.开放定址法： 当发生冲突时，按照顺序向前找个空闲位置，来存储冲突的key</p>
<p>2.链式存址法： 简单点理解就是把hash冲突的key，以单向链表存储，比如hashmap</p>
<p>3.再hash法： 当发生冲突时，通过另外一个hash对他进行运算，知道不冲突为止，这种方式会增加计算时间，性能会有影响</p>
<p>4.建立公共溢出区 ：把hash表分为基本表和益处表，凡是存在冲突的，都放到溢出表</p>
<hr>
<h2 id="5-hashmap在jdk1-8的优化"><a href="#5-hashmap在jdk1-8的优化" class="headerlink" title="5.hashmap在jdk1.8的优化?"></a>5.<strong>hashmap在jdk1.8的优化?</strong></h2><p>HashMap在JDK1.8版本中是通过链式寻址法以及红黑树来解决Hash冲突的问题，其中红黑树是为了优化Hash表的链表过长导致时间复杂度增加的问题，当链表长度大于等于8并且Hash表的容量大于64的时候，再向链表添加元素，就会触发链表向红黑树的一个转化</p>
<hr>
<h2 id="6-HashMap如何减少碰撞"><a href="#6-HashMap如何减少碰撞" class="headerlink" title="6.HashMap如何减少碰撞?"></a>6.<strong>HashMap如何减少碰撞?</strong></h2><p>1.扰动函数：使元素位置分布均匀，减少碰撞几率</p>
<p>2.使用final对象，采用合适的equals()和hashcode()方法</p>
<hr>
<h2 id="7-HashMap线程同步吗？"><a href="#7-HashMap线程同步吗？" class="headerlink" title="7.HashMap线程同步吗？"></a>7.<strong>HashMap线程同步吗？</strong></h2><p>Collections.synchronizeMap(hashmap)</p>
<hr>
<h2 id="8-为啥我们重写equals方法的时候需要重写hashCode方法呢？"><a href="#8-为啥我们重写equals方法的时候需要重写hashCode方法呢？" class="headerlink" title="8.为啥我们重写equals方法的时候需要重写hashCode方法呢？"></a>8.为啥我们重写equals方法的时候需要重写hashCode方法呢？</h2><p>hashmap中value的查找通过key的哈希值进行的查找比对，所以说自己的对象必须重写hashcode方法，然后找到对象，用equals()你叫你传入的对象和 判断他的key是否相同，还要重写equals。</p>
<hr>
<h2 id="9-Hashmap在什么时候进行扩容"><a href="#9-Hashmap在什么时候进行扩容" class="headerlink" title="9.Hashmap在什么时候进行扩容?"></a>9.<strong>Hashmap在什么时候进行扩容?</strong></h2><p>hashmap数组长度等于64 (最大64)</p>
<p>链表长度大于8</p>
<h2 id="10-hashmap如何扩容的"><a href="#10-hashmap如何扩容的" class="headerlink" title="10.hashmap如何扩容的?"></a>10.<strong>hashmap如何扩容的?</strong></h2><p>当map中的元素个数(数组，链表和红黑树) 超过16.0.75=12 之后开始扩容。</p>
<p>新建一个原来的hashmap 2倍的bucket 数组，对原来数组copy，这也叫refresh，将会调用hash方法找到新的bucket位置。</p>
<hr>
<h2 id="11-HashMap中的初始容量和加载因子"><a href="#11-HashMap中的初始容量和加载因子" class="headerlink" title="11.HashMap中的初始容量和加载因子"></a>11.<strong>HashMap中的初始容量和加载因子</strong></h2><p>通过查看HashMap底层源码的初始默认容量16，加载因子0.75.</p>
<p><strong>容量:</strong> 是<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%93%88%E5%B8%8C%E8%A1%A8&spm=1001.2101.3001.7020">哈希表</a>中桶的数量，初始容量只是哈希表在创建时的容量</p>
<p><strong>加载因子:</strong> 是哈希表在其容量自动扩容之前可以达到多满的一种度量</p>
<p>当哈希值超出了加载因子和当前容量的乘积时,就会进行扩容, refesh操作, 扩容后的哈希表将具有两倍的原容量</p>
<h2 id="12-加载因子高低的问题"><a href="#12-加载因子高低的问题" class="headerlink" title="12.加载因子高低的问题?"></a>12.加载因子高低的问题?</h2><ul>
<li>加载因子过高，例如为1，这样会减少空间开销，提高空间利用率，但同时会增加查询时间的成本</li>
<li>加载因子过低，例如为0.5，虽然可以减少查询时间，但是空间利用率很低，同时提高了rehash操作的次数</li>
</ul>
<hr>
<h2 id="13-hashmap和hashtable的区别"><a href="#13-hashmap和hashtable的区别" class="headerlink" title="13.hashmap和hashtable的区别?"></a>13.hashmap和hashtable的区别?</h2><p>hashmap和hashtable都是实现了map接口，hashmap等价于hashtable，hashmap是线程不安全的，hashtable是线程安全</p>
<p>( synchronized)，</p>
<p>多线程是不能共享hashmap，可共享hashtable。</p>
<p>在java5里提供了concurrentHashMap，是hashtable的替代，比它的扩展性好。</p>
<p><strong>hashmap:16， key和valuekey为null</strong></p>
<p><strong>hashtable:11  key和value不能为null</strong></p>
<p>都是实现map接口，hashmap是把hashtable的contains方法去掉了，改成了containsKey和containsvalue。</p>
<p>hashmap是线程不安全，不能共享多线程，hashtable线程安全，能共享</p>
<h2 id="13-ConcurrentHashMap"><a href="#13-ConcurrentHashMap" class="headerlink" title="13.ConcurrentHashMap?"></a>13.ConcurrentHashMap?</h2><hr>
<h2 id="14-JDK1-7扩容的时候为什么要重新Hash呢，为什么不直接复制过去？"><a href="#14-JDK1-7扩容的时候为什么要重新Hash呢，为什么不直接复制过去？" class="headerlink" title="14.JDK1.7扩容的时候为什么要重新Hash呢，为什么不直接复制过去？"></a>14.<strong>JDK1.7扩容的时候为什么要重新Hash呢，为什么不直接复制过去？</strong></h2><p>因为长度扩大以后，hash规则也改变了，比如原来长度为8，位运算是2，长度变16，结果肯定不一样。</p>
<hr>
<h2 id="15-HashMap-amp-ConcurrentHashMap的区别"><a href="#15-HashMap-amp-ConcurrentHashMap的区别" class="headerlink" title="15.HashMap&amp;ConcurrentHashMap的区别?"></a><strong>15.HashMap&amp;ConcurrentHashMap的区别?</strong></h2><p>除了枷锁，其他没太大区别。hashmap键值对可以为空，concurrenthashmap不允许为空。</p>
<h2 id="16-HashTable-amp-ConcurrentHashMap的效率要高"><a href="#16-HashTable-amp-ConcurrentHashMap的效率要高" class="headerlink" title="16.HashTable&amp;ConcurrentHashMap的效率要高?"></a><strong>16.HashTable&amp;ConcurrentHashMap的效率要高?</strong></h2><p><strong>hashtable:</strong></p>
<p>HashTable使用一把锁(锁住整个链表结构)处理并发问题,多个线程竞争一把锁,容易阻塞;</p>
<p><strong>ConcurrentHashMap:</strong>  </p>
<p>**在JDK1.7:**concurrentHashmap()， 桶数组进行了分割分段(Segment)， 每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发性能高，线程安全</p>
<p>相当于把一个hashmap分成多段，每段一把锁，支持多线程访问。锁粒度：基于segment，包含多个hashentry。</p>
<p><strong>JDK1.8</strong> 的时候已经摒弃了Segment的概念，直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化</p>
<hr>
<h1 id="二九、Java集合中的快速失败（fast-fail）机制"><a href="#二九、Java集合中的快速失败（fast-fail）机制" class="headerlink" title="二九、Java集合中的快速失败（fast-fail）机制?"></a>二九、Java集合中的快速失败（fast-fail）机制?</h1><p>快速失败是java集合的一种错误机制，多个线程对集合进行现呈上的改的操作时，有可能会产生fast-fail。</p>
<p>比如： 线程1和线程2，线程1通过iterator遍历集合a的元素，在线程2修改集合a的结构，那么程序就会抛出ConcurrentModification异常，从而产生fast-fail。</p>
<h2 id="那么快速失败机制底层是怎么实现的呢？"><a href="#那么快速失败机制底层是怎么实现的呢？" class="headerlink" title="那么快速失败机制底层是怎么实现的呢？"></a><strong>那么快速失败机制底层是怎么实现的呢？</strong></h2><p>迭代器遍历是直接访问集合中的内容，遍历过程中使用的modcount的数量，如果集合遍历期间发生变化，就会改变modcount。当迭代器使用hashNext()和next()遍历下一个元素前，就会检测modcount变量是否exceptedModCount值，是的话就遍历，佛则就抛异常，终止遍历。</p>
<p>ConcurrentModificationException :  当检测到一个并发的修改(结构)，就可能会抛出异常，一旦迭代器抛出此异常，就可以快速失败。</p>
<hr>
<h2 id="为什么String-Interger这样的wrapper类适合作为键？"><a href="#为什么String-Interger这样的wrapper类适合作为键？" class="headerlink" title="为什么String, Interger这样的wrapper类适合作为键？"></a><strong>为什么String, Interger这样的wrapper类适合作为键？</strong></h2><p>String比较常用，因为他是不可变的，是final，而且重写了equals和hashcode方法，其他wrapper类也有这个 特点，不可变性，为了计算hashcode，防止键值改变，如果放入和取出的hash值不一样，那么就获取不到此对象，不可变性有其他的优点如线程安全</p>
<hr>
<h1 id="三十、什么是WebSocket"><a href="#三十、什么是WebSocket" class="headerlink" title="三十、什么是WebSocket?"></a>三十、<strong>什么是WebSocket?</strong></h1><p>轮询是指浏览器每隔一段时间向服务器发出http请求，然后服务器返回最新的数据给客户端。</p>
<p>WebSocket 是一种网络传输协议，可在单个 TCP(传输控制协议) 连接上进行全双工通信，位于 OSI 模型的应用层。</p>
<p>Websocket是的客户端和服务器之间数据交换变得更加简单，允许服务端主动向客户端推送数据，在websocketAPI中，浏览器和服务器只需要完成一次握手，就可以建立长久的链接，进行双向数据传输。</p>
<hr>
<h1 id="三一、什么是ELK"><a href="#三一、什么是ELK" class="headerlink" title="三一、什么是ELK?"></a>三一、<strong>什么是ELK?</strong></h1><p>Elk是对日志数据做解决的框架，</p>
<p>E 指Elasticsearch, 用于负责日志的存储和检索。</p>
<p>L 指Logstash，负责日志收集，过滤和格式化，</p>
<p>K 指Kibana负责日志的展示统计和数据的可视化。</p>
<h2 id="Elk能做什么？"><a href="#Elk能做什么？" class="headerlink" title="Elk能做什么？"></a><strong>Elk能做什么？</strong></h2><p>应用出现故障，需要通过日志排查故障，当应用部署多个环境，这事排查就是巨大的消耗。elk对多个环境日志进行收集，过滤，存储，检错，可视化。只需要在kibana查看日志，就能照着故障。</p>
<p>ELK 组件在海量日志系统的运维中，可用于解决：</p>
<p>分布式日志数据集中式查询和管理、系统监控，包含系统硬件和应用各个组件的监控、故障排查、安全信息和事件管理、报表功能等等</p>
<p><img src="/../gg/Image-168371837218528.png" srcset="/img/loading.gif" lazyload alt="Image"></p>
<h2 id="什么是filebeat"><a href="#什么是filebeat" class="headerlink" title="什么是filebeat?"></a><strong>什么是filebeat?</strong></h2><p>Filebeat是用于转发和集中日志数据的轻量级传送工具。Filebeat监视您指定的日志文件或位置，收集日志事件，并将它们转发到Elasticsearch或 Logstash进行索引。</p>
<h2 id="什么是elasticsearch"><a href="#什么是elasticsearch" class="headerlink" title="什么是elasticsearch?"></a><strong>什么是elasticsearch?</strong></h2><p>Elasticsearch是Apache下的lucene搜索服务器,它提供了分布式多用户全文搜索引擎，基于restful web接口。是当前最流行的企业级搜索引擎。能够实时搜索，快速安装方便。</p>
<p>通过索引去存储，index=数据库 ，type=表，document=一行数据。</p>
<p>shards是索引的主分片，把索引拆分为多个主分片，分别存储在不同的节点上。</p>
<p><img src="/../gg/Image-168371836380526.png" srcset="/img/loading.gif" lazyload alt="Image"></p>
<h2 id="什么是logstash"><a href="#什么是logstash" class="headerlink" title="什么是logstash?"></a><strong>什么是logstash?</strong></h2><p>Logstash是一个用于管理日志和时间的工具，可以收集、解析、转换、过滤日志，作为模块提供给其他模块调用，搜索，存储。</p>
<h2 id="什么是kibana"><a href="#什么是kibana" class="headerlink" title="什么是kibana?"></a><strong>什么是kibana?</strong></h2><p>Kibana是一个优秀的前端日志展示框架，可以非常详细的将日志转化为各种图表，为用户提供强大的数据可视化支持。</p>
<h2 id="ELK的优势"><a href="#ELK的优势" class="headerlink" title="ELK的优势?"></a><strong>ELK的优势?</strong></h2><p>1.强大的搜索功能。</p>
<p>2.完美的展示功能</p>
<p>3.分布式功能</p>
<hr>
<h1 id="三二、什么是redis"><a href="#三二、什么是redis" class="headerlink" title="三二、什么是redis?"></a>三二、<strong>什么是redis?</strong></h1><p>redis是一个开源的，内存中的数据结构存储系统，可以用作数据库、缓存、消息中间件。支持多种数据结构，(string,hash,list,set,zset) ,提供了丰富的的api操作这些数据结构，redis具有高性能，可扩展性，高可用性，被广泛于web应用程序，分布式系统，实时处理。]</p>
<h2 id="redis的数据类型"><a href="#redis的数据类型" class="headerlink" title="redis的数据类型?"></a><strong>redis的数据类型?</strong></h2><ol>
<li>String </li>
<li>Hash</li>
<li>List</li>
<li>Set</li>
<li>zset</li>
</ol>
<h2 id="redis版本？"><a href="#redis版本？" class="headerlink" title="redis版本？"></a><strong>redis版本？</strong></h2><p><strong>redis6.0之前是单线程指的是其网络i/o和键值对读写是由一个线程完成的</strong></p>
<p><strong>redis6.0网络请求用了多线程，键值对读写仍是单线程处理，所以redis并发依然是安全的。</strong></p>
<p><strong>6.0之前redis网络请求和数据操作是单线程的，其他持久化和集群数据同步是额外线程执行的。</strong></p>
<hr>
<h1 id="三三、数据库分库分表"><a href="#三三、数据库分库分表" class="headerlink" title="三三、数据库分库分表"></a>三三、<strong>数据库分库分表</strong></h1><p>数据库分库分表后，需要对数据库进行处理，让我们在应用层dao操作，能像正常单一的数据源一样，不影响dao业务逻辑。</p>
<h3 id="什么是ShardingSphere"><a href="#什么是ShardingSphere" class="headerlink" title="什么是ShardingSphere?"></a><strong>什么是ShardingSphere?</strong></h3><p>是Apache ShadingSphere的第一个产品，轻量级的java框架，在java的jdbc层提供额外服务，是客户端直连数据库，可以增强jdbc驱动。完全兼容jdbc和各种orm框架。</p>
<p>适用于任何jdbc的orm框架。</p>
<p>支持任何第三方的数据库链接池。Druid，1ĀHikariCP。</p>
<p>支持实现JDBC规范的数据库。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理?"></a><strong>原理?</strong></h3><p>sharding-jdbc框架集成在应用端，应用执行jdbc dao操作，被sharding jdbc框架拦截，进行本地的sql解析,改写，解析道不同的表根据分片的规则(如where id=1)路由到不同的库和表，实现分库分表，返回结果归并，因为一条sql可能涉及到多个库和表的联查，返回给dao操作。</p>
<p>当Sharding-JDBC接受到一条SQL语句时，会陆续执行 SQL解析 =&gt; 查询优化 =&gt; SQL路由 =&gt; SQL改写 =&gt; SQL执行 =&gt;结果归并 ，最终返回执行结果。</p>
<p><img src="/../gg/Image-168371834833924.png" srcset="/img/loading.gif" lazyload alt="Image"></p>
<p><img src="/../gg/Image-168371834454222.png" srcset="/img/loading.gif" lazyload alt="Image"></p>
<p><img src="/../gg/Image-168371834012620.png" srcset="/img/loading.gif" lazyload alt="Image"></p>
<h3 id="shardingsphere优缺点？"><a href="#shardingsphere优缺点？" class="headerlink" title="shardingsphere优缺点？"></a>shardingsphere优缺点？</h3><p><strong>优点</strong></p>
<p>1.基于aop原理，在webapp本地进行sql拦截，解析，改写、路由、结果归并处理。</p>
<p>2.效率高</p>
<p><strong>缺点?</strong></p>
<p>1.实现分库分表需要改动代码，引入jar包。</p>
<p>2.只支持java语言实现。</p>
<p><img src="/../gg/Image-168371828315614.png" srcset="/img/loading.gif" lazyload alt="Image"></p>
<p>总结:</p>
<p>一个是本地拦截处理（sharding-jdbc），一个是服务器端拦截处理(mycat)。</p>
<ul>
<li><p>sharding-jdbc作为一个组件集成在应用内，而mycat则作为一个独立的应用需要单独部署。</p>
</li>
<li><ul>
<li>合分布式架构的设计，直连数据库，没有中间应用，理论性能是最高的。</li>
</ul>
</li>
<li><p>从耦合性来看，sharding-jdbc需要集成在应用内，集成到代码里，使得开发成本相对较高；而mycat大致上是无损开发，不需要怎么修改代码，交给mycat去托管，分库分表等代码无需太多关注。</p>
</li>
</ul>
<hr>
<h2 id="mycat"><a href="#mycat" class="headerlink" title="*mycat*"></a><em><strong>*mycat*</strong></em></h2><p>是一个开源的企业级数据库，支持事务，ACID，可以替代Mysql加强版数据库。可视为mysql集群的企业级数据，代替昂贵的oracle。</p>
<h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a><strong>原理</strong></h2><p><strong><img src="/../gg/Image-168371833190018.png" srcset="/img/loading.gif" lazyload alt="Image"></strong></p>
<p>由mycat处理罗技表和实体表的实际操作，应用层链接mycat，跟链接mysql数据库一样，应用程序操作逻辑表，逻辑表通过配置对应实体表，应用程序层不做处理，mycat安在服务器端，在服务器端进行实际sql执行，实际执行和shardingsphere一样，解析改写路由，结果归并操作。</p>
<p>Mycat的原理中最重要的一个动词是“拦截”，它拦截了用户发送过来的SQL语句，首先对SQL语句做了一些特定的分析：如<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8&spm=1001.2101.3001.7020">分库分表</a>分析、路由分析、读写分离分析、缓存分析等，然后将此SQL发往后端的真实数据库，并将结果归并给用户。</p>
<h3 id="mycat优缺点"><a href="#mycat优缺点" class="headerlink" title="mycat优缺点?"></a><strong>mycat优缺点?</strong></h3><p><strong>优点:</strong></p>
<p>1.mycat安装在服务器上的中间件工具，代码里直接连接mycat，由mycat做sql的改写并发结果归并，保证数据库的安全性，支持多种开发语言的连接。</p>
<p>2.不用调整代码就可实现分库分表，将数据库连接到mycat地址。</p>
<p><strong>缺点:</strong></p>
<p>1.效率低</p>
<p><img src="/../gg/Image-168371831922716.png" srcset="/img/loading.gif" lazyload alt="Image"></p>
<hr>
<h1 id="三四、优化Mysql数据库的8种方法"><a href="#三四、优化Mysql数据库的8种方法" class="headerlink" title="三四、优化Mysql数据库的8种方法?"></a>三四、<strong>优化Mysql数据库的8种方法?</strong></h1><p><strong>1.创建索引</strong>  </p>
<p>创建索引可以提高性能，但也要创建有用的索引，不然还是会影响性能</p>
<p><strong>2.复合索引</strong></p>
<p><strong>3.索引不包含NULL值</strong></p>
<p>4.使用短索引</p>
<p>5.排序的索引问题</p>
<p>6.like语句操作</p>
<p>7.不要在列上进行运算</p>
<p>8.不要使用not in’ 和&lt;&gt;操作</p>
<h2 id="优化数据库的方法？"><a href="#优化数据库的方法？" class="headerlink" title="优化数据库的方法？"></a><strong>优化数据库的方法？</strong></h2><p>1.选取合适的字段属性</p>
<p>2.使用join链接 代替子查询</p>
<p>3.使用联合union来代替手动创建临时表</p>
<p>4.事务处理</p>
<p>5.锁定表优化事务</p>
<p>6.使用外键 优化锁定表</p>
<p>7.建立索引</p>
<p>8.优化查询语句</p>
<h2 id="如何优化mysql"><a href="#如何优化mysql" class="headerlink" title="如何优化mysql?"></a><strong>如何优化mysql?</strong></h2><p>1.SQL语句及索引优化</p>
<p>2.数据库表结构优化</p>
<p>3.系统配置优化</p>
<p>4.硬件的优化</p>
<h2 id="对sql语句优化有哪些方法"><a href="#对sql语句优化有哪些方法" class="headerlink" title="对sql语句优化有哪些方法?"></a><strong>对sql语句优化有哪些方法?</strong></h2><p>1.where子句: where表之间的链接必须写在where条件前，过滤嘴大条件必须写在where子句末尾，HAVING最后。</p>
<p>2.用exists替代in、用not exists替代not in</p>
<p>3.避免在索引列上使用计算</p>
<p>4.避免索引上使用is null 和 not null</p>
<p>5.对查询进行优化，应尽量避免全表扫描， 首先应考虑在 where 及 order by 涉及的列上建立索引。</p>
<p>\6. 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描</p>
<p>\7. 应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描</p>
<h1 id="三五、什么是数据库的三大范式"><a href="#三五、什么是数据库的三大范式" class="headerlink" title="三五、什么是数据库的三大范式?"></a>三五、<strong>什么是数据库的三大范式?</strong></h1><p><strong>第一范式(1NF):</strong> 列不可再分</p>
<p>​     \1. 每一列属性都不可再分属性值，确保每一列的原子性</p>
<p><img src="/../gg/Image-168371826967512.png" srcset="/img/loading.gif" lazyload alt="Image"></p>
<p><strong>第二范式(2NF):</strong> 属性依赖于主键 </p>
<p>​     1.第二范式满足第一范式，就是根据主键或者联合主键,将一个表最有关联的属性分别放在一起</p>
<p><img src="/../gg/Image-168371826519710.png" srcset="/img/loading.gif" lazyload alt="Image"></p>
<p><img src="/../gg/Image-16837182584728.png" srcset="/img/loading.gif" lazyload alt="Image"></p>
<p>​     </p>
<p><strong>第三范式(3NF):</strong>   满足第二范式；且不存在传递依赖，即非主属性不能与非主属性之间有依赖关系，非主属性必须直接依赖于主属性，不能间接依赖主属性。（A -&gt; B, B -&gt;C, A -&gt; C）</p>
<p>3NF是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。</p>
<p><img src="/../gg/Image-16837182527606.png" srcset="/img/loading.gif" lazyload alt="Image"></p>
<p><img src="/../gg/Image-16837182469734.png" srcset="/img/loading.gif" lazyload alt="Image"></p>
<p><strong>范式化设计优缺点:</strong></p>
<p>优点:</p>
<p>  可以尽量减少数据冗余，值更新快，体积小</p>
<p>缺点：</p>
<p>  对于查询需要多个表进行关联，减少写的效率增加读的效率，更难进行索引优化</p>
<p>反范式化:</p>
<p>优点:</p>
<p>  减少表的关联,更好的进行索引优化</p>
<p>缺点:</p>
<p>  数据冗余以及数据异常，数据修改需要很多成本</p>
<h1 id="三六、过滤器（Filter）是什么"><a href="#三六、过滤器（Filter）是什么" class="headerlink" title="三六、过滤器（Filter）是什么?"></a>三六、过滤器（Filter）是什么?</h1><p>过滤器，是在java web中将你传入的request、response提前过滤掉一些信息，或者提前设置一些参数。然后再传入Servlet或Struts2的 action进行业务逻辑处理。比如过滤掉非法url（不是login.do的地址请求，如果用户没有登陆都过滤掉），或者在传入Servlet或Struts2的action前统一设置字符集，或者去除掉一些非法字符。</p>
<h2 id="拦截器（Interceptor）"><a href="#拦截器（Interceptor）" class="headerlink" title="拦截器（Interceptor）?"></a><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%8B%A6%E6%88%AA%E5%99%A8&spm=1001.2101.3001.7020">拦截器</a><strong>（Interceptor）?</strong></h2><p>拦截器，是面向切面编程（AOP，Aspect Oriented Program）的。就是在你的Service或者一个方法前调用一个方法，或者在方法后调用一个方法。</p>
<h2 id="过滤器与拦截器的区别"><a href="#过滤器与拦截器的区别" class="headerlink" title="过滤器与拦截器的区别"></a><strong>过滤器与拦截器的区别</strong></h2><p>过滤器可以简单的理解为“取你所想取”，过滤器关注的是web请求；拦截器可以简单的理解为“拒你所想拒”，拦截器关注的是方法调用，比如拦截敏感词汇。</p>
<p>1.拦截器是基于java反射机制来实现的，而过滤器是基于函数回调来实现的。（有人说，拦截器是基于动态代理来实现的）</p>
<p>2.拦截器不依赖servlet<a target="_blank" rel="noopener" href="https://cloud.tencent.com/product/tke?from=20065&from_column=20065">容器</a>，过滤器依赖于servlet容器。</p>
<p>3.<strong>拦截器只对Action起作用</strong>，过滤器可以对所有请求起作用。</p>
<p>4.拦截器可以访问Action上下文和值栈中的对象，过滤器不能。</p>
<p>5.在Action的生命周期中，拦截器可以多次调用，而过滤器只能在容器初始化时调用一次。</p>
<p><img src="/../gg/Image-16837182330562.png" srcset="/img/loading.gif" lazyload alt="Image"></p>
<p>   6.过滤器是在请求进入容器（Tomcat）之后，但是请求进入Servlet之前。请求结束返回时也是，是在Servlet处理完之后，返回给前端之前</p>
<h2 id="自定义拦截器的步骤"><a href="#自定义拦截器的步骤" class="headerlink" title="自定义拦截器的步骤"></a><strong>自定义拦截器的步骤</strong></h2><p>第一步：自定义一个实现了Interceptor接口的类，或者继承抽象类AbstractInterceptor。</p>
<p>第二步：在配置文件中注册定义的拦截器。</p>
<p>第三步：在需要使用Action中引用上述定义的拦截器，为了方便也可以将拦截器定义为默认的拦截器，这样在不加特殊说明的情况下，所有的Action都被这个拦截器拦截。</p>
<h1 id="三七、Springboot的自动装配"><a href="#三七、Springboot的自动装配" class="headerlink" title="三七、Springboot的自动装配?"></a>三七、<strong>Springboot的自动装配?</strong></h1><p>Spring Boot的自动装配基于Spring框架的基本原理——依赖注入和控制反转。在Spring框架中，依赖注入指的是将对象所需要的其他对象注入到它的属性中，而控制反转则是将对象的创建和管理交给Spring容器，而不是由开发者手动创建和管理。</p>
<p>在Spring Boot中，自动装配的原理可以用以下流程来概括：</p>
<p>扫描所有的jar包，查找META-INF/spring.factories文件，该文件列出了所有自动配置类的全限定名。</p>
<p>加载自动配置类，将它们实例化，并将它们注册到Spring容器中。</p>
<p>根据用户的配置，选择需要的自动配置类。用户可以通过@ConfigurationProperties注解来配置Spring Boot应用程序的属性。根据这些属性的值，Spring Boot会选择需要加载的自动配置类。</p>
<p>根据选择的自动配置类，将需要的依赖项注入到应用程序中。这些依赖项包括其他的配置类、数据源、消息队列、WebMvc框架等。Spring Boot会在运行时自动根据需要加载这些依赖项，并将它们注入到应用程序中。</p>
<p>使用条件注解（@Conditional）过滤不符合条件的自动配置类。例如，在应用程序中使用了MySQL数据库，Spring Boot会自动加载MySQL数据库的自动配置类。如果应用程序中没有使用MySQL数据库，那么Spring Boot就不会加载MySQL数据库的自动配置类，减少不必要的资源消耗。</p>
<p>总的来说，Spring Boot的自动装配基于Spring框架提供的依赖注入和控制反转机制，通过自动加载和注入依赖项，让开发者可以快速构建应用程序，提高开发效率。同时，Spring Boot的自动装配机制也确保了应用程序的可配置性和可扩展性。</p>
<hr>
<h2 id="Springboot自动装配？"><a href="#Springboot自动装配？" class="headerlink" title="Springboot自动装配？"></a><strong>Springboot自动装配？</strong></h2><p>在@SpringBootApplication注解里的@EnableAutoConfiguration用@Import注解导入了一AutoConfigurationImportSelector.class类，这个类的selectImports方法会扫描我们类路径下的一个spring.factories文件（里面装的是很多官方写好的自动配置类的全限定名），然后返回这些类的名字。</p>
<h2 id="自动装配约定大于配置"><a href="#自动装配约定大于配置" class="headerlink" title="自动装配约定大于配置"></a><strong>自动装配约定大于配置</strong></h2><p>Spring Boot 为我们提供了一些默认的配置和实现，如果我们的项目中按照默认的规则命名和配置了组件，那么 Spring Boot 会自动为我们进行配置，从而减少了我们的配置量和开发难度。</p>
<hr>
<h1 id="三八、全局异常的处理"><a href="#三八、全局异常的处理" class="headerlink" title="三八、全局异常的处理?"></a>三八、<strong>全局异常的处理?</strong></h1><p><img src="/../gg/Image.png" srcset="/img/loading.gif" lazyload alt="Image"></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div></div>
      <div>http://example.com/2023/05/10/Java笔记/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>May 10, 2023</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/05/04/hello-world/" title="Hello World">
                        <span class="hidden-mobile">Hello World</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
